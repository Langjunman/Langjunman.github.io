<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基于双目立体视觉的人脸特征点三维坐标测量</title>
    <url>/2021/04/22/binocular-face1/</url>
    <content><![CDATA[<p>使用双目相机拍摄人脸图像，然后用OpenCV自带的人脸识别工具识别出人脸的特征点，利用双目视觉成像原理确定特征点在物理空间的三维坐标，精度能达到亚毫米级。</p>
<span id="more"></span>

<h1 id="双目视觉成像原理"><a href="#双目视觉成像原理" class="headerlink" title="双目视觉成像原理"></a>双目视觉成像原理</h1><h2 id="单个相机成像"><a href="#单个相机成像" class="headerlink" title="单个相机成像"></a>单个相机成像</h2><p>这个部分网上资料很多，在此仅作简单介绍。</p>
<p>为了描述物理世界的一个点到相机图像中的转换关系，需要建立下图所示的四个坐标系：世界坐标系(Ow-XwYwZw)、相机坐标系(Oc-XcYcZc)、图像坐标系(o-xy)、像素坐标系(uv)。</p>
<p><img src="http://langjxblog.oss-cn-beijing.aliyuncs.com/img/coordinate1.png" alt="坐标系示意图"></p>
<p>图中物理世界的点P最终要显示在相机图片中，用像素坐标系表示，因此需要建立世界坐标系到像素坐标系的转换关系。如下图公式所示。我们的目的是输入u、v，输出X<sub>w</sub>、Y<sub>w</sub>、Z<sub>w</sub> ，因此解决其他未知参数即可解方程。公式中包含相机的内参和外参，其中内参有焦距（fx、fy），主点坐标（x0、y0），坐标轴倾斜参数s（理想情况下为0），外参即旋转矩阵R<sub>3x3</sub>、t<sub>3x1</sub>。</p>
<p><img src="http://langjxblog.oss-cn-beijing.aliyuncs.com/img/formula1.png" alt="公式1"></p>
<p>相机的内参和外参可以通过相机标定来解决。常见的标定方法有OpenCV自带的标定函数和Matlab标定工具两种，根据个人经验，Matlab标定方便卫生起效快，很容易获得误差极小的标定结果，具体操作网上也很容易搜到，不再赘述。</p>
<h2 id="双目相机坐标计算"><a href="#双目相机坐标计算" class="headerlink" title="双目相机坐标计算"></a>双目相机坐标计算</h2><p>通过双目视觉计算三维坐标主要有两种方法，一种是光轴会聚模型（又叫三角测量，《<em><strong>Multiple View Geometry in Computer Vision</strong></em>》中有详细介绍），依赖于上文提到的转换关系，另一种是光轴平行模型。根据个人的应用场景，光轴平行模型精度略差，再加上这种方法大部分应用于立体匹配，因此本文不多叙述。</p>
<p>在光轴会聚模型中，物理世界的点P到两个相机分别都具有上述转换关系，每个相机对应一个方程，联立两个方程，用最小二乘法即可求得三维坐标。为什么要用最小二乘法，而不是求一个精确的值？那是因为像下图这样，由于一些不可消除的误差存在，例如相机畸变，图像噪声等，使得映射的两条射线不相交，也就没有交点P存在。因此只能使用最小二乘法计算出一个误差最小的点P坐标。</p>
<p><img src="http://langjxblog.oss-cn-beijing.aliyuncs.com/img/triangulation.jpg" alt="triangulation"></p>
<p>OpenCV中集成了这个方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::<span class="built_in">triangulatePoints</span>(T1, T2, pts_1, pts_2, pts_4d);</span><br></pre></td></tr></table></figure>

<ul>
<li>T1，T2是两个相机标定后的外参（平移矩阵R和旋转矩阵T）拼接而成的两个3x4矩阵，在上面的公式中也有体现，长下面这样：</li>
</ul>
<p><img src="http://langjxblog.oss-cn-beijing.aliyuncs.com/img/extrinsic1.jpg" alt="T1和T2"></p>
<p><strong>注意：</strong></p>
<p><strong>1.T1应该是个3x4的零矩阵，因为相机1的外参代表从相机1转换到相机1自身，不需要平移和旋转。</strong>  </p>
<p><strong>2. 输入的参数pts_1和pts_2应该是相机坐标系下的点，如果刚开始获得的点是像素坐标系下的话（u,v）需要转换到相机坐标系</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat T1 = (cv::Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt;   <span class="comment">//这是我项目里的实际参数</span></span><br><span class="line">	<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">	<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">	<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">cv::Mat T2 = (cv::Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt;</span><br><span class="line">	<span class="number">0.999977229479619</span>, <span class="number">-0.00532193046070156</span>, <span class="number">0.00414940699831593</span>, <span class="number">-119.261032810442</span>,</span><br><span class="line">	<span class="number">0.00532910465608532</span>, <span class="number">0.999984321284919</span>, <span class="number">-0.00171983368511187</span>, <span class="number">-0.197778050925297</span>,</span><br><span class="line">	<span class="number">-0.00414018910566970</span>, <span class="number">0.00174190714775862</span>, <span class="number">0.999989912245948</span>, <span class="number">-2.50548372131854</span></span><br><span class="line">	);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>pts_1，pts_2是输入的两幅图像中点P的像素坐标，pts_4d是输出的齐次坐标，简单处理一下就能变成3维坐标（前三项分别除以第四项，变成Xw，Yw，Zw）。把输入和输出的点扩展成多个点也能照常使用。</li>
</ul>
<h1 id="人脸特征点检测"><a href="#人脸特征点检测" class="headerlink" title="人脸特征点检测"></a>人脸特征点检测</h1><p>人脸特征点（facial landmarks），也可以叫人脸关键点，是人脸面部比较显著的一系列位置。目前常见的人脸特征点检测方法，会选择面部最为显著的68个特征点作为检测对象。在本文中，使用双目相机拍摄人脸图像，并做人脸特征点检测，左右两幅图像中均检测到对应的特征点之后，就能利用双目视觉计算人脸特征点的三维坐标，进而确定人脸的位置，应用到头动跟踪和点云配准里面。</p>
<p><img src="http://langjxblog.oss-cn-beijing.aliyuncs.com/img/facial_landmarks.png" alt="人脸特征点"></p>
<p>OpenCV里面集成的人脸特征点检测方法是出自《<em><strong>Face Alignment at 3000 FPS via Regressing Local Binary Features</strong></em>》这篇论文，顾名思义速度非常快，也能同时检测出一幅图中多个人脸，缺点是错误率比较高，会把一些不是人脸的地方也检测为人脸，但也可以经过简单的修改提高表现。</p>
<p>首先需要导入OpenCV的一些头文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/calib3d/calib3d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/face/facemark.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/objdetect.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/face/facemarkLBF.hpp&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>然后加载训练好的模型和人脸特征分类器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::CascadeClassifier faceDetector;</span><br><span class="line">cv::Ptr&lt;cv::face::Facemark&gt; facemark;</span><br><span class="line"><span class="keyword">this</span>-&gt;facemark-&gt;<span class="built_in">loadModel</span>(<span class="string">&quot;lbfmodel.yaml&quot;</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;faceDetector = cv::<span class="built_in">CascadeClassifier</span>(<span class="string">&quot;haarcascade_frontalface_alt2.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>接下来就需要读入图像并识别图像中的人脸了，注意拍摄到的图像是有畸变的，需要利用相机的标定结果（内参矩阵和畸变参数）来消去畸变：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//相机内参矩阵</span></span><br><span class="line">cv::Mat Mml1 = (cv::Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt;</span><br><span class="line">	<span class="number">814.331542566370</span>, <span class="number">2.54302537477624</span>, <span class="number">320.166811462154</span>,</span><br><span class="line">	<span class="number">0</span>, <span class="number">816.348689641441</span>, <span class="number">239.130200710676</span>,</span><br><span class="line">	<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">cv::Mat Mml2 = (cv::Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt;</span><br><span class="line">	<span class="number">813.005491652729</span>, <span class="number">2.01737529125153</span>, <span class="number">322.141637483107</span>,</span><br><span class="line">	<span class="number">0</span>, <span class="number">815.153838450258</span>, <span class="number">232.732313416557</span>,</span><br><span class="line">	<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//相机畸变参数，1-5行分别为K1，K2，P1，P2，K3。K是径向畸变，P是切向畸变，注意别搞错了排放顺序</span></span><br><span class="line">cv::Mat Dml1 = (cv::Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">5</span>, <span class="number">1</span>) &lt;&lt;</span><br><span class="line">	<span class="number">-0.598617485967720</span>,</span><br><span class="line">	<span class="number">0.473453551957653</span>,</span><br><span class="line">	<span class="number">0.00169547674384290</span>,</span><br><span class="line">	<span class="number">0.000208409890958463</span>,</span><br><span class="line">	<span class="number">-0.933829145147369</span>);</span><br><span class="line">cv::Mat Dml2 = (cv::Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">5</span>, <span class="number">1</span>) &lt;&lt;</span><br><span class="line">	<span class="number">-0.596710310550388</span>,</span><br><span class="line">	<span class="number">0.110101991305559</span>,</span><br><span class="line">	<span class="number">0.00194901593490481</span>,</span><br><span class="line">	<span class="number">0.000724389850583840</span>,</span><br><span class="line">	<span class="number">2.92541612872564</span>);</span><br><span class="line"></span><br><span class="line">cv::Mat image1,image2;</span><br><span class="line">cv::<span class="built_in">undistort</span>(<span class="keyword">this</span>-&gt;left_image, image1, Mml1, Dml1);<span class="comment">//undistort是OpenCV提供的去畸变函数</span></span><br><span class="line">cv::<span class="built_in">undistort</span>(<span class="keyword">this</span>-&gt;right_image, image2, Mml2, Dml2);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>声明存放人脸的变量，注意这里用了vector是因为OpenCV的人脸识别方法会检测出图像中所有的人脸，不一定只有一个，然后将检测到的人脸存到faces1和faces2中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;cv::Rect&gt; faces1;<span class="comment">//存放人脸</span></span><br><span class="line">std::vector&lt;cv::Rect&gt; faces2;</span><br><span class="line">std::vector&lt; vector&lt;Point2f&gt; &gt; landmarks1;<span class="comment">//存放特征点</span></span><br><span class="line">std::vector&lt; vector&lt;Point2f&gt; &gt; landmarks2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;faceDetector.<span class="built_in">detectMultiScale</span>(image1, faces1);<span class="comment">//识别人脸</span></span><br><span class="line"><span class="keyword">this</span>-&gt;faceDetector.<span class="built_in">detectMultiScale</span>(image2, faces2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> success1 = <span class="keyword">this</span>-&gt;facemark-&gt;<span class="built_in">fit</span>(img1, faces1, landmarks1);<span class="comment">//在识别到人脸的基础上检测人脸特征点</span></span><br><span class="line"><span class="keyword">bool</span> success2 = <span class="keyword">this</span>-&gt;facemark-&gt;<span class="built_in">fit</span>(img2, faces2, landmarks2);</span><br></pre></td></tr></table></figure>

<p>检测出特征点后就可以显示在图像上，并且计算关键点的三维坐标了（使用第一部分提到的cv::triangulatePoints函数）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (success1 &amp;&amp; success2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//画出特征点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; landmarks1[<span class="number">0</span>].<span class="built_in">size</span>(); idx++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">circle</span>(image1, landmarks1[<span class="number">0</span>][idx], <span class="number">2</span>, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>),<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">circle</span>(image2, landmarks2[<span class="number">0</span>][idx], <span class="number">2</span>, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>),<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示图像</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">result</span><span class="params">(image1.size().height, image1.size().width * <span class="number">2</span>, image1.type())</span></span>;</span><br><span class="line">	cv::Mat part1 = <span class="built_in">result</span>(cv::<span class="built_in">Rect</span>(<span class="number">0</span>, <span class="number">0</span>, image1.<span class="built_in">size</span>().width, image1.<span class="built_in">size</span>().height));</span><br><span class="line">	cv::Mat part3 = <span class="built_in">result</span>(cv::<span class="built_in">Rect</span>(image2.<span class="built_in">size</span>().width, <span class="number">0</span>, image1.<span class="built_in">size</span>().width, image1.<span class="built_in">size</span>().height));</span><br><span class="line"></span><br><span class="line">	cv::<span class="built_in">resize</span>(img1, part1, part1.<span class="built_in">size</span>(), <span class="number">0</span>, <span class="number">0</span>, cv::INTER_AREA);</span><br><span class="line">	cv::<span class="built_in">resize</span>(img2, part2, part2.<span class="built_in">size</span>(), <span class="number">0</span>, <span class="number">0</span>, cv::INTER_AREA);</span><br><span class="line"> </span><br><span class="line">	cv::<span class="built_in">imshow</span>(<span class="string">&quot;result&quot;</span>, result);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算三维坐标</span></span><br><span class="line">    vector&lt;cv::Point2f&gt; pts_1, pts_2;<span class="comment">//临时保存像素坐标系点变换到相机坐标系点的变量</span></span><br><span class="line">	std::vector&lt;std::vector&lt;<span class="keyword">float</span>&gt;&gt; <span class="built_in">xyz</span>(landmarkNum, std::vector&lt;<span class="keyword">float</span>&gt;(<span class="number">3</span>, <span class="number">0.0</span>));<span class="comment">//xyz即输出的三维坐标，landmarkNum即为68</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; landmarkNum; count++)</span><br><span class="line">	&#123;</span><br><span class="line">		pts_1.<span class="built_in">push_back</span>(<span class="built_in">pixel2cam</span>(landmarks1[<span class="number">0</span>][count], Mml1));<span class="comment">//注意这里的pixel2cam是把点从像素坐标系转换到相机坐标系的函数</span></span><br><span class="line">		pts_2.<span class="built_in">push_back</span>(<span class="built_in">pixel2cam</span>(landmarks2[<span class="number">0</span>][count], Mml2));</span><br><span class="line">	&#125;</span><br><span class="line">	cv::Mat pts_4d = cv::<span class="built_in">Mat</span>(<span class="number">4</span>, landmarkNum, CV_32F);<span class="comment">//输出变量，函数输出的是齐次坐标，所以是4x68</span></span><br><span class="line">    </span><br><span class="line">    cv::<span class="built_in">triangulatePoints</span>(T1, T2, pts_1, pts_2, pts_4d);<span class="comment">//用最小二乘法求三维坐标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pts_4d.cols; i++)<span class="comment">//归一化，即将齐次坐标转换为非齐次坐标(x,y,z)</span></span><br><span class="line">	&#123;</span><br><span class="line">		cv::Mat x = pts_4d.<span class="built_in">col</span>(i);</span><br><span class="line">		x /= x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">3</span>, <span class="number">0</span>); </span><br><span class="line">		<span class="function">cv::Point3d <span class="title">p</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">			x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>, <span class="number">0</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">			x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>, <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">		)</span></span>;</span><br><span class="line">		xyz[i][<span class="number">2</span>] = p.z;</span><br><span class="line">		xyz[i][<span class="number">0</span>] = p.x;</span><br><span class="line">		xyz[i][<span class="number">1</span>] = p.y;</span><br><span class="line">		std::cout &lt;&lt; p.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.z &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把点从像素坐标系转换到相机坐标系的函数</span></span><br><span class="line"><span class="function">cv::Point2f <span class="title">pixel2cam</span><span class="params">(<span class="keyword">const</span> cv::Point2d&amp; p, <span class="keyword">const</span> cv::Mat&amp; K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> cv::Point2f</span><br><span class="line">	(</span><br><span class="line">		(p.x - K.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">2</span>)) / K.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">		(p.y - K.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">2</span>)) / K.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="http://langjxblog.oss-cn-beijing.aliyuncs.com/img/face1.png" alt="face"></p>
<p><img src="http://langjxblog.oss-cn-beijing.aliyuncs.com/img/xyz1.png" alt="xyz"></p>
<p>如果想求某些特定的点的话，只需按照上面图片中给出的特征点序号，选择landmarks1和landmarks2里面特定的点即可。</p>
<p>到此，基于双目立体视觉的人脸特征点三维坐标测量也就完成了。如果你也照着大概实现了一遍，你会发现存在一些问题：</p>
<ol>
<li>OpenCV的人脸识别会经常把图片中不是人脸的地方当做人脸= =</li>
<li>识别出来的特征点会明显抖动，不稳定</li>
</ol>
<p>针对这些问题，当然存在着解决方案，敬请期待后续博文更新。</p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>双目视觉</tag>
        <tag>人脸识别</tag>
      </tags>
  </entry>
  <entry>
    <title>如何提升OpenCV人脸识别方法准确率</title>
    <url>/2021/05/05/binocular-face2/</url>
    <content><![CDATA[<p> OpenCV自带的人脸识别方法会识别同一幅图像上所有的人脸，同时也会把并不是人脸的地方识别成人脸，这就对使用者带来不便。那么如何优化这个方法，使其能够正常有效地运行呢？</p>
<span id="more"></span>

<h1 id="OpenCV人脸识别的不准问题"><a href="#OpenCV人脸识别的不准问题" class="headerlink" title="OpenCV人脸识别的不准问题"></a>OpenCV人脸识别的不准问题</h1><p><img src="http://langjxblog.oss-cn-beijing.aliyuncs.com/img/wrong_face.png" alt="wrong_face"></p>
<p>上图就是直接使用OpenCV人脸识别方法经常会发生的情况了。对于我目前的使用场景，我只想要图片中识别出唯一正确的人脸。所以我使用了如下两种改进方法：设置ROI和人脸排序。</p>
<h1 id="设置ROI"><a href="#设置ROI" class="headerlink" title="设置ROI"></a>设置ROI</h1><p>ROI（region of interest）就是感兴趣区域，在此处具体来讲就是人脸比较容易出现的区域。由于我目前使用的是双目相机，根据双目相机的成像规律，人脸通常会出现在左相机的右侧，以及右相机的左侧，具体可以看下图</p>
<p><img src="http://langjxblog.oss-cn-beijing.aliyuncs.com/img/stereo1.jpg" alt="stereo1"></p>
<p>从图中可以看出，人脸的图像总是会在左相机的右边，在右相机的左边，因此我把这两个区域设置为ROI，让OpenCV的人脸识别只识别ROI区域，这样非ROI区域就不会被识别了。</p>
<p>具体设置如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cv::Rect <span class="title">RectROI1</span><span class="params">(<span class="number">300</span>, <span class="number">100</span>, <span class="number">340</span>, <span class="number">300</span>)</span></span>;  <span class="comment">//把ROI画出来,括号内分别是图像的x,y,width,height，注意x轴是从左往右为正，y轴是从上往下为正</span></span><br><span class="line"><span class="function">cv::Rect <span class="title">RectROI2</span><span class="params">(<span class="number">0</span>, <span class="number">100</span>, <span class="number">340</span>, <span class="number">300</span>)</span></span>;</span><br><span class="line">cv::<span class="built_in">rectangle</span>(image1, RectROI1, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>); 	</span><br><span class="line">cv::<span class="built_in">rectangle</span>(image2, RectROI2, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">cv::Mat imageROI1 = <span class="built_in">image1</span>(<span class="built_in">Range</span>(<span class="number">100</span>, <span class="number">340</span>), <span class="built_in">Range</span>(<span class="number">300</span>, <span class="number">640</span>)); <span class="comment">//正式设置每幅图像的ROI，四个参数分别是上下左右</span></span><br><span class="line">cv::Mat imageROI2 = <span class="built_in">image2</span>(<span class="built_in">Range</span>(<span class="number">100</span>, <span class="number">340</span>), <span class="built_in">Range</span>(<span class="number">0</span>, <span class="number">340</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;faceDetector.<span class="built_in">detectMultiScale</span>(imageROI1, faces1);<span class="comment">//这里再修改一下输入参数，不是原图像，而是ROI</span></span><br><span class="line"><span class="keyword">this</span>-&gt;faceDetector.<span class="built_in">detectMultiScale</span>(imageROI2, faces2);</span><br><span class="line"></span><br><span class="line">faces1[<span class="number">0</span>] = faces1[<span class="number">0</span>] + <span class="built_in">Point</span>(<span class="number">300</span>, <span class="number">100</span>); <span class="comment">//识别出来的人脸的坐标是在ROI区域内的，需要转换到原图像中</span></span><br><span class="line">faces2[<span class="number">0</span>] = faces2[<span class="number">0</span>] + <span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">	</span><br><span class="line"><span class="comment">//其他步骤和前文就一致了</span></span><br></pre></td></tr></table></figure>

<p>结果如下图：</p>
<p><img src="http://langjxblog.oss-cn-beijing.aliyuncs.com/img/ROI1.jpg" alt="ROI"></p>
<p>可以看到，设置ROI之后，人脸检测的范围就被缩小到大的绿色框内了，识别成功的概率有提升。如果在你的应用场景中，人脸也是会通常出现在特定区域，那么你也可以利用这个方法试一试。</p>
<p>等等，右边图像的背景墙上有一部分还是被当做人脸，如何解决这个问题？</p>
<h1 id="人脸排序"><a href="#人脸排序" class="headerlink" title="人脸排序"></a>人脸排序</h1><p>通过大量测试发现，OpenCV误把非人脸区域识别成人脸的情况下，错误人脸bounding-box是明显小于真正人脸bounding-box的，因此可以把识别到的所有“人脸”降序排列，第一个就是真正的人脸啦。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//降序排列</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comparison</span><span class="params">(cv::Rect a, cv::Rect b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.width &gt; b.width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">sort</span>(faces1.<span class="built_in">begin</span>(), faces1.<span class="built_in">end</span>(), comparison);</span><br><span class="line">std::<span class="built_in">sort</span>(faces2.<span class="built_in">begin</span>(), faces2.<span class="built_in">end</span>(), comparison);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个人脸用绿框，其余用红框</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; faces1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        cv::<span class="built_in">rectangle</span>(img1, faces1[i], cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cv::<span class="built_in">rectangle</span>(img1, faces1[i], cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; faces2.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        cv::<span class="built_in">rectangle</span>(img2, faces2[i], cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cv::<span class="built_in">rectangle</span>(img2, faces2[i], cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://langjxblog.oss-cn-beijing.aliyuncs.com/img/sort.png" alt="sort"></p>
<p>结果如图，这样就能确保得到真正的人脸了。这些框框只是为了讲明白是怎么一回事画的，实际上我的工程里面没有画这些红的绿的框，只标出了人脸特征点，需不需要画自己决定。</p>
<p>经过设置ROI和人脸排序两个步骤，OpenCV的人脸识别方法已经有很大的改良了，能够投入正常使用中。除此之外有没有其他比较方便的实现人脸识别的办法呢？你好，有的。那就是Dlib，下一篇文章就介绍如何在OpenCV里面使用Dlib进行人脸识别吧。</p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉</tag>
        <tag>人脸识别</tag>
      </tags>
  </entry>
</search>
